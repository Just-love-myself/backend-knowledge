# Tactical Design

[DDD-Lite 참고 링크](https://jiwondev.tistory.com/237)

## 전술적 설계 (Tactical Design)

전략적 설계, 보편 언어를 통해 도메인 모델을 발견했다고 가정했을 때, \
이를 그대로 설계, 코드에 반영하는 걸 **모델 주도 설계**라고 한다.

제일 코드랑 맞닿아 있고, 전략적 설계가 아닌 전술적 설계만 적용하면 DDD Lite라고 부르기도 한다.

도메인 모델은 몇 가지로 구분할 수 있는데, 대표적인 패턴은 아래와 같다.

1. Entity
2. Value Object
3. Aggregate
4. Repository

## Entity

ERD에서의 Entity랑 혼동할 수 있다. DDD에선 객체의 Entity의 의미로 사용된다.

객체 Entity는식별자(Identifier)가 존재하고, 이를 통해 동일성(Identity)을 확인한다면 Entity라고 할 수 있다.

이는 일반적으로 이야기하는 개체(Entity)와 구별되고, 이런 혼란을 막기 위해 우리는 OOP 또는 DDD라는 Bounded Context 안에서 Entity를 다룰 것이다

## Value Object

어떤 객체는 연속성, 식별성이 중요하지 않다. 만 원은 그냥 만 원으로 다루는 게 “여기 있는 만 원”과 “저기 있는 만 원”이 다르다고 주장하는 것보다 훨씬 유용하다. 즉, 우리의 쇼핑몰 비즈니스 도메인을 다루기에 적합한 추상화, 모델링이라고 할 수 있다. 이 때 사용되는 게 바로 Value Object다.

만약 검은 돈을 추적하고 있다면 “여기 있는 만 원”과 “저기 있는 만 원”은 일련번호 등으로 구분해서 다뤄야 하고, 이건 일련번호를 Identifier로 갖는 Entity라고 할 수 있다. 즉, 어떤 것이 Entity인지 Value Object인지는 미리 정해진 게 아니다. 오로지 우리의 **비즈니스 도메인에 달려 있다**고 할 수 있다.

* Value Object는 속성을 통해 동등성(Equality)을 판단한다.&#x20;
* 즉, Value Object는 항상 Java의 equals 메서드를 구현해야 한다.\
  (+ hashcode()도 같이 오버라이딩 해야한다.)
* 예측 가능성을 높이고 혼란을 막기 위해, 가능하면 불변 객체로 만들어야 한다.&#x20;

## Aggregate(집합체, 애그리거트)

참고 링크 : [Aggregate](https://devlos.tistory.com/51)

### 애그리거트 뜻

* 데이터 변경의 단위로 다루는 **연관 객체의 묶음**
* **연관된 엔티티와 값 객체(VO)들의 묶음**

### 애그리거트와 개별객체로 표현한 쇼핑몰 도메인

애그리거트는 모델이나 비즈니스 도메인을 이해하기 위한 거시적인 방법으로 사용된다.

**개별 객체 수준**의 모델만을 참고하여 도메인을 분석하게 되면 무엇이 중요하고 핵심인지 한눈에 파악하기가 힘들다.&#x20;

하지만 **애그리거트 단위**로 도메인을 먼저 이해한 후 객체 수준의 모델을 바라보게 된다면 이해하기가 훨씬 쉽다. 즉, 우리가 다뤄야 할 도메인 객체의 개수를 적절하게 조절해 준다.

아래의 그림은 애그리거트만 표현한 다이어그램이다.

<figure><img src="../../.gitbook/assets/애그리거트 도메인.png" alt=""><figcaption><p>애그리거트 도메인</p></figcaption></figure>

<figure><img src="../../.gitbook/assets/애그리거트만 있는 도메인.png" alt=""><figcaption><p>애그리거트만으로 표현한 도메인</p></figcaption></figure>

### 애그리거트 성질

애그리거트의 핵심은 도메인을 이해하기 쉬운 단순한 구조로 만들어 주는 것이다. \
애그리거트는 연관된 개별 객체를 묶어서 만들어지기 때문에 몇 가지 성질을 가진다.

* 애그리거트에 속한 객체는 **유사하거나 동일한 생명주기(Life cycle)**를 가진다.\
  주문이라는 행위를 할 때, 주문 객체를 만들면서 주문 항목, 주문한 사람, 배송 정보 등의 객체를 함께 만든다.&#x20;
  * CascadeType.ALL + orphanRemoval=true 같이 써주는 걸 권장한다.
* 애그리거트는 **경계를 가진다**.\
  한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.

> 대다수의 Aggregate는 하나의 핵심 엔티티(애그리거트 루트이면서)와 여러 개의 VO로 구성된다.
>
> 두 개 이상의 엔티티로 구성된 애그리거트는 드물게 존재한다.

### 애그리거트 루트

애그리거트 전체를 관리할 주체를 의미한다.&#x20;

예제에서는 주문 애그리거트의 주문 엔티티가 루트이다.&#x20;

애그리거트 루트는 애그리거트의 **일관성이 깨지지 않도록 하는 것**이다. \
(일관성이란 도메인 규칙을 지키는 것을 의미한다. 예: 주문 총 금액 = 개별 상품의 주문 개수 x 가격)

**애그리거트 루트가 제공하는 메서드**는 도메인 규칙에 따라 애그리거트에 속한 **객체의 일관성이 깨지지 않도록 구현**해야한다. 애그리거트 루트가 아닌 **다른 객체**가 애그리거트에 속한 객체를 **직접 변경하면 안된다.**&#x20;

일관성을 직접적으로 깨뜨리는 예로는, 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 변경하려고 하는 것이다.

```java
//order 애그리거트에서 ShippingInfo VO를 얻은 뒤, 
ShippingInfo si = order.getShippingInfo(); 
si.setAddress(newAddress);
```

불필요한 중복을 피하고 **애그리거트 루트를 통해서만 도메인 로직을 구현**하게 만들려면 두 가지 습관이 있어야 한다.

1. **단순히 필드를 변경하는 setter를 public 범위로 만들지 않는다.**\
   도메인 로직이 응용 계층이나 표현 계층으로 분산되지 않도록 방지하는 역할을 한다. set 형식 이름 말고 cancel이나 changePassword처럼 의미가 더 잘 드러나는 이름을 사용할 빈도가 높아진다.
2. **VO(Value Object)은 불변으로 구현한다.**\
   VO가 불변이면 VO의 값을 변경하는 방법은 새로운 VO를 전달해서 값을 변경하는 방법밖에 없도록 하여 일관성을 유지한다.

### Vaughn Vernon의 4가지 경험 법칙

적절한 Aggregate 경계를 찾는 건 어려운 일이다. 도메인에 대한 지식도 있어야한다.&#x20;

아래 4가지 법칙을 참고해서 적용해보자.

IDDD의 저자인 Vaughn Vernon은 4가지 경험 법칙을 제안한다:

1. **불변식**을 통해 일관성 경계를 찾아서 모델링한다. Aggregate은 **트랜잭션적 일관성** 경계와 동의어다.
2. 작은 Aggregate으로 설계한다.
3. ID로 다른 Aggregate을 참조한다. JPA 등을 사용하면 관련된 객체를 모두 직접 참조할 수 있게 되는데, 그렇게 하지 않는다.
4. 경계 밖에선 **결과적 일관성**을 사용한다. 이를 위해 도메인 이벤트 등을 사용할 수 있다.

### 불변식

불변식이란 하나의 맥락에서 지켜져야 하는 제약사항이다.

애그리거트 내에 속한 요소들은 애그리거트의 무결성을 보장하기 위해, 긴밀하게 연관되어 있는 경우가 많다. 이 연관관계, 혹은 제약조건을 DDD에선 Invariant라고 부른다.

수학적 정의로 c= a + b에서 a, b가 주어졌을 때 c의 값을 확정지을 수 있어야한다는 것이다.

마찬가지로, DDD에서 애그리거트에는 애그리거트 내의 구성 요소들의 상태(a,b)가 주어졌을 때, 특정 조건(c)을 만족해야 하는 경우가 많다.

예를 들어, 주문 애그리거트에는 주문 애그리거트 루트와 주문 항목들 엔티티가 존재할 수 있습니다. 주문 항목들 엔티티의 상태(가격, 아이템, 개수)가 주어졌을 경우 주문 애그리거트 루트의 특정 조건(주문 총액 = 주문 항목들의 합)을 만족해야 합니다.

### 트랜잭션적 일관성과 결과적 일관성

## Repository

Repository는 Aggregate를 관리하는 Collection처럼 작동한다. 이는 두 가지 의미를 갖는데,

1. 오직 Aggregate만 Repository를 갖는다. (Aggregate 별로 하나의 Repository 사용)
2. Repository는 영속화 방법 및 기술을 감춘다.

Spring Data JPA는 이 둘을 만족시키기 위한 기능을 갖추고 있다.&#x20;

* Aggregate만 Repository를 갖도록 하위 Entity나 VO들에게도 상태 전파가 이루어져야한다.
* 애그리거트는 관련된 모델을 하나로 묶은 것이기 때문에 애그리거트에 속한 객체들은 유사하거나 동일한 라이프 사이클을 갖는다
* CascadeType.ALL + orphanRemoval = true로 설정한다.
* Persistence Context를 통해 Collection처럼 쓸 수 있게한다.\
  ex) find()하면 항상 같은 객체를 반환해준다.

정리해보자면,

1. 적절한 Aggregate 경계를 찾는다.
2. 책임 분배를 위해 적절히 Entity, VO로 구성
3. Aggregate를 위한 Repository 생성

이를 통해 여러 기술 문제와 무관한 비즈니스 도메인에 집중할 수 있게 된다.

이렇게 비즈니스 도메인에 집중한 코드를 모아둔 곳을 Domain Layer라고 부르며, \
Repository와 Aggregate를 사용하는 코드가 모인 곳을 Application Layer(여기선 애플리케이션의 기능, Use Case가 직접적으로 드러나게 된다), \
Web 등 구체적인 기술로 사용자와 소통하는 코드가 모인 곳을 UI Layer라고 부른다..

이게 바로 Layered Architecture가 DDD와 함께 다뤄지는 이유다.

## Aggregate 경계 찾는 법 관련해서 추가로 참고할만한 부분

[DDD 전략적 설계](https://tech.junhabaek.net/ddd-%EC%A0%84%EB%9E%B5%EC%A0%81-%EC%84%A4%EA%B3%84-eventstorming-%EC%95%A0%EA%B7%B8%EB%A6%AC%EA%B1%B0%ED%8A%B8-event-grouping-b9188b1b7665) <- 여기서 이벤트 스토밍 개념이 등장한다.

이벤트 스토밍과 관련된 게시물이다.

[이벤트 스토밍-1](https://velog.io/@suhongkim98/MSA%EC%99%80-DDD-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%8A%A4%ED%86%A0%EB%B0%8D-3)

[이벤트 스토밍-2](https://devlos.tistory.com/54)
